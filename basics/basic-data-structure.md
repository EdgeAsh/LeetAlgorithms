## 堆
堆其实是一种优先级队列，在很多语言都有对应的内置数据结构，很遗憾javascript没有这种原生的数据结构。 不过这对我们理解和运用不会有影响。
需要注意的是优先队列不仅有堆一种，还有更复杂的，但是通常来说，我们会把两者做等价
#### 堆分为`大顶堆`和`小顶堆`根据最值在顶进行分类
1. 大顶堆：双亲节点大于或等于子节点(堆数组A，每个元素A[i]，我们将得到A[i] >= A[i * 2 + 1]和A[i] >= A[i * 2 + 2])
2. 小顶堆：双亲节点小于或等于子节点(堆数组A，每个元素A[i]，我们将得到A[i] <= A[i * 2 + 1]和A[i] <= A[i * 2 + 2])

#### 如何堆化
> 堆化就是将(无序)数组变成堆数组(大/小顶堆)
1. 大顶堆
    - 将每个元素A[i]，得到A[i] >= A[i * 2 + 1]和A[i] >= A[i * 2 + 2]
    ```
    function swap(arr, i){
        if(arr[i] < arr[2*i+1]) {
            arr[i] ^= arr[2*i+1]
            arr[2*i+1] ^= arr[i]
            arr[i] ^= arr[2*i+1]
        }
        if(arr[i] < arr[2*i+2]) {
            arr[i] ^= arr[2*i+2]
            arr[2*i+2] ^= arr[i]
            arr[i] ^= arr[2*i+2]
        }
    }
    /**
    * 大顶堆化
    * 找到最后一个非叶子节点A[i]，调整顺序；
    * i--再调整，但是新换值可能会影响上次调整的堆，
    * 因此每遍历一次都需要判断上次的堆顺序
    */
    function maxHeapify(arr) {
        let lastRoot = (arr.length >> 1) - 1;
        for(let i=lastRoot; i>=0 ; i--) {
            swap(arr, i)
            // 重新整理上次堆顺序 **这一逻辑处理有问题// TODO**
            if(i < lastRoot) {
                swap(arr, i+1)
            }
        }
        return arr;
    }
    ```
2. 小顶堆
    - 将每个元素A[i]，得到A[i] <= A[i * 2 + 1]和A[i] <= A[i * 2 + 2]

#### 关键问题
1. 最后一个非叶子节点下标如何确认？
    > i = Math.floor(arr.length/2 - 1) 
2. 检验堆的时机
