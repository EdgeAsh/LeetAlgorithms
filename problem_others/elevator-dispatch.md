### 题目
```
微软亚洲研究所所在的希格玛大厦一共有6部电梯。在高峰时间，每层都有人上下，电梯在每层都停。实习生小飞常常会被每层都停的电梯弄得很不耐烦，于是他提出了这样一个办法：
由于楼层并不太高看没在繁忙的上下班时间，每层电梯从一层往上走时，我们只允许电梯停在其中的某一层。所有的乘客都从一楼上电梯，到达某层楼后，电梯停下来，所有乘客再从这里爬楼梯到自己的目的层。
在一楼的时候，每个乘客选择自己的目的层，电梯则自动计算出应停的楼层。
问：电梯停在哪一层楼，能够保证这次乘坐电梯的所有乘客爬楼梯的层数之和最少。

扩展：

1.如何在O(n)的时间复杂度完成？
2.往上爬楼梯，总是比往下走要累的。假设往上爬一个楼层，要耗费k单位的能量，而往下走只需要耗费1单位的能量，那么如果题目条件改为让所有人消耗的能量最少，这个问题怎么解决呢？
这个问题可以用类似上面的分析方法来解答看，因此笔者不再累述，留给读者自行解决。
3.在一个高楼里面，电梯只在某一个楼层停，这个政策还是不太人性化。如果电梯会在k个楼层停呢？读者可以发挥自己的想象力，看看如何寻找最优方案。
```

### 题意
每层都停 => 只停一层，其余让人爬楼梯；所有人爬梯之和最小
选择目的层(i)，在i层下的人数是T[i]，根据大家选择的目的层计算在哪一层(X)停最优
$\sum_{i=0}^n$$\lbrace$T[i]$\times$$\mid$i - x$\mid$$\rbrace$

### 思路 
从简单易想到的方式开始； 
从1楼开始直到顶层，算出在每层人需要爬梯的总和数组result 
找出Min(result)下标 
时间复杂度是O(N^2) 

进一步考虑 
假设在i层停，共需要爬Y阶；在i层有N2人，在i层以下共N1人，i层以上共N3人。 
如果在i-1层停，相比i层变化Y+N2+N3-N1 = Y - (N1-N2-N3) => N1 > (N2 + N3)时会减少爬阶数 
如果在i+1层停，相比i层变化Y-N3+N2+N1 = Y - (N3-N2-N1) => N3 > (N2 + N1)时会减少爬阶数 
所以在N1 > N2+N3时应该在i-1层停，N3 > N2+N1时应该在i+1层停; 否则在i层停 

现在我们以第一层作为初始，算出i=1时Y的值还有N3;对结果进行优化，只要Y可以减少就是优化的方向 
N3 > N2 + N1时可以在i+1层停 

中位数方法
假设两个人在2楼和9楼下。那么在2-9楼之间任意层停，两人走楼梯的层数和是不变的

### 代码
```js
/**
* 两个测试用例
* nPerson = [0, 1, 3, 4, 2, 3]
* nPerson = [0, 1, 0, 2, 2, 6]
*/

function original(nPerson) { // nPerson首元素设0，使楼层与下标对应
  // nPerson[i] 在i层下的人， N 总楼层
  let result = [0]; // 存各层结果
  let target = 1; // 最小值下标
  for(let x = 1; x < nPerson.length; x++) { // 目标楼层x
    result[x]=0;
    for(let i = 1; i < nPerson.length; i++) { // 人在哪层停留
      result[x] += nPerson[i]*Math.abs(x-i);
    }
    if(result[target] > result[x]) {
      target = x
    }
  }
  return target;
}

function betterOne(nPerson) { // 首元素设空, 下标就与楼层对应了，nPerson的长度-1就是楼层数
    let N1 = 0;
    let N2 = nPerson[1];
    let N3 = 0;
    let Y = 0; // Y在这里是无用的
    let target = 1;
    // 第一层时，算出人需要走的楼梯数Y和在一楼以上的人数N3
    for(let i = 2; i < nPerson.length; i++) {
        N3 += nPerson[i];
        Y += nPerson[i]*(i-1);
    }
    // 再来优化
    for(let i = 2; i < nPerson.length; i++) {
        if (N1+N2 < N3) { // 在i+1层停比较好
            target = i;
            Y += (N1 + N2 - N3);
            N1 += N2
            N3 -= nPerson[i]
            N2 = nPerson[i]
        }
    }
    return target
}
```

### 感想
第一次做[编程之美]题，比较紧张无措；因为自己内心给它的设定是高大上的！认为它不会简单。
但是做过一个之后，并不是所有题都难；`初代代码`写出来之后发现这个好普通啊；这里有一个将生活中的问题抽象的过程，一段话里你得分得清常量变量，因为它不会告诉你常量是什么变量是什么。将一切理清楚这个过程是在leetcode上没有的(leetcode上先给函数+参数,省了点力气)，我要做的是抽象后的代码，适合机器跑的代码。
这题就是，我们人脑设计路线。计算机去跑去找

[编程之美]自己写代码不知道是否正确，没有测试用例。还需要自己测试；否则只能抄代码才能保证正确(那样也就失去意义了)

关于第二种O(N)的表示法，解法包含两个for循环也是O(N)让我不能理解。是O(2N)才对

这个优化问题如果没有代码，我肯定做不出来的。因为理解别人代码都很困难，没有前面公式的推导也就不会有后面的代码
作者是怎么想到这种方式的啊，我当时看公式推导的时候根本想不到怎样写代码；如果不是要把代码写出来，里面的具体细节我就不知道


### 新概念
无后向性(无后效性)概念第一次听到是在群里面，但这概念是跟动态规划挂钩的。动态规划适用的情况之一就是无后向性。
来自[动态规划-无后效性](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92#%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5)
: 即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。 -- 好好理解这句话
